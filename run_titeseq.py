'''
This script takes the CSV input generated by 05_write_titeseq_input and performs
the Tite-Seq analysis in parallel.
'''

from KD_fit_log_poiss import x_star, hill
import numpy as np
import time
import stat_collector as sc
import argparse
import os
import pandas as pd
from itertools import imap
import multiprocessing
from functools import partial
from scipy.optimize import curve_fit
from lmfit import Model

### TiteSeq parameters and utilities

from titeseq_utils import *

### Run parameters

'''
If args.mode is "x_star", the x_star algorithm from KD_fit_log_poiss.py will be
used. If the mode is "naive", a simple fitting algorithm will be used instead.
If the mode is "mass-titer", the Mass-Titer approach using lmfit will be used.
'''
MODE_X_STAR = "x_star"
MODE_NAIVE = "naive"
MODE_MT = "mass_titer"

'''
List of expression strings which will be evaluated and written out to the
params.txt file.
'''
PARAMETER_LIST = ["args.input", "args.output", "args.mode", "READ_COUNT_COLUMN_RANGE", "NORMALIZED_COUNT_COLUMN_RANGE", "BINS_VARY_FIRST", "BINS_ORDER_ASCENDING", "CONCENTRATIONS_ORDER_ASCENDING", "bin_fluorescences", "concentrations", "k_scan", "basal", "KD_scan", "s_scan", "DEFAULT_B_VALUE", "MINIMUM_TOTAL_READ_COUNT", "args.treat_as_output"]

### Naive algorithm

def hill_optimizer(x, K, s, b):
    '''
    Calls the hill function from KD_fit_log_poiss (this re-implementation is
    necessary to satisfy the order of arguments for scipy.optimize.curve_fit).
    '''
    return hill(K, s, b, x)

def naive_titeseq(R, T, fl):
    '''
    Uses a simple SciPy optimizer to fit the Kd for the given R and T matrices,
    with fl is a numpy array of the concentrations over the titration.
    Returns (predicted_x, fit_Kd, fit_s, fit_b, covariance) where the 'fit_'
    values are the parameters to the Hill function. predicted_x is a list of
    predicted mean bin values according to the fit coefficients.
    '''
    # Fit to the mean bin values
    data = average_bin_positions(R)
    fit_params, covariance = curve_fit(hill_optimizer, fl, data, bounds=(1e-10, np.array([0.1, 10, 10])))
    K, s, b = fit_params
    predicted_x = hill_optimizer(fl, K, s, b)
    return predicted_x, K, s, b, covariance

# Mass-Titer
def run_lmfit(x, y, init0, sat0, Kd0, graph):
    '''
    The Mass-Titer
    x: concentration list
    y: average bin positions
    init0: lower limit
    sat0: upper limit
    Kd0: initial Kd
    graph: whether or not to display the graph
    '''
    # takes input arrays, initial guesses, plotting boolean
    # returns values in a dict, kd/stderr as values

    if np.isnan(y).any():
        return None

    def basic_fit(x, init, sat, Kd):
        return init + (sat - init) * x / (x + Kd)

    gmod = Model(basic_fit)
    result = gmod.fit(y, x=x, init=init0, sat=sat0, Kd=Kd0)
    dct2 = {'xscale':'log'}
    r2 = 1 - result.redchi / np.var(y, ddof = 2)

    init = result.params['init'].value
    sat = result.params['sat'].value
    kd = result.params['Kd'].value
    fit_positions = basic_fit(x, init, sat, kd)

    if graph == True:
        result.plot_fit(numpoints=10000, ax_kws=dct2)
        #result.plot_fit(numpoints=1000)
        print(result.fit_report())
        return fit_positions, kd, sat, init, result.params['Kd'].stderr, result.chisqr, r2

    else:
        return fit_positions, kd, sat, init, result.params['Kd'].stderr, result.chisqr, r2

### Helpers for running

def format_for_csv(value):
    '''Returns a string (in scientific notation) for the given number.'''
    return "{:.4e}".format(value)

def format_log_for_csv(value):
    '''Returns a shorter decimal string for the given number.'''
    return "{:.2f}".format(value)

def run_x_star_processor(mode, input_vals):
    '''
    Helper function for run_x_star that runs in a multiprocessing pool. Takes
    an input of the form (R, T, b, seq) and returns a list of strings that can
    be joined and returned in CSV format.
    '''
    if input_vals is None:
        return None
    R, T, b, seq = input_vals
    if mode == MODE_X_STAR:
        result = x_star(R, T, b, k_scan, bin_fluorescences, basal, KD_scan, s_scan, concentrations)
        if result is None:
            return None

        x, KD, s, KD_sigma, get_obj, prob, log_prob, try_LL, k_guess = result
        return [seq] + [format_for_csv(val) for val in x.flatten()] + [format_for_csv(KD), format_for_csv(s), format_for_csv(basal), format_for_csv(KD_sigma), format_for_csv(try_LL), format_for_csv(k_guess)]

    elif mode == MODE_NAIVE:
        result = naive_titeseq(R, T, concentrations)
        if result is None:
            return None

        x, KD, s, b, cov = result
        # Convert average bin position to all values - when the 'average bin position'
        # is calculated for this output, it should equal what we got here
        x = fake_bin_data_from_averages(x)
        return [seq] + [format_for_csv(val) for val in x.flatten()] + [format_for_csv(KD), format_for_csv(s), format_for_csv(b)] + [format_for_csv(val) for val in cov.flatten()]

    elif mode == MODE_MT:
        averages = average_bin_positions(R / T).flatten()
        print(R, T, averages)
        result = run_lmfit(concentrations, averages, MT_LOWER, MT_UPPER, MT_KD_INITIAL, False)
        if result is None:
            return None

        x, KD, s, b, err, chi, r2 = result
        # Convert average bin position to all values - when the 'average bin position'
        # is calculated for this output, it should equal what we got here
        x = fake_bin_data_from_averages(x)
        return [seq] + [format_for_csv(val) for val in x.flatten()] + [format_for_csv(KD), format_for_csv(s), format_for_csv(b), format_for_csv(err), format_for_csv(chi), format_for_csv(r2)]
    else:
        assert False, "Unidentified mode: {}".format(mode)

def run_x_star(in_path, out_path, mode, line_num=None, num_processes=5, treat_as_output=False):
    '''
    Takes as input the path to the output of 05_write_titeseq_input, which is a
    CSV containing sequences, their counts in all the Tite-Seq bins, and their
    normalized counts. This method interprets the normalized counts into the
    correct inputs for x_star (see KD_fit_log_poiss.py), runs x_star, and writes
    the output in CSV format to out_path.

    If line_num is not None, it can be an index representing the line number of the
    sequence for which to compute x_star.

    Mode can be either MODE_X_STAR or MODE_NAIVE - see the documentation near
    TITESEQ_MODE for more details.
    '''
    df = pd.read_csv(in_path, header=None)
    df = df.rename(columns={0:'seq'})

    # Clear output file
    if out_path is not None:
        open(out_path, 'w').close()

    raw_start, raw_end = READ_COUNT_COLUMN_RANGE
    if treat_as_output:
        # The input file is a run_titeseq output file. Get the x array from positions 1-NM.
        raw_start = 1
        raw_end = 1 + raw_end - raw_start
        col_start, col_end = raw_start, raw_end
        T = reshape_from_csv_format(np.ones(raw_end - raw_start))
    else:
        col_start, col_end = NORMALIZED_COUNT_COLUMN_RANGE
        # Generate T matrix (sum of --normalized-- trying RAW counts per CSV column)
        total_read_counts = df.iloc[:,raw_start:raw_end].sum().as_matrix().astype(np.float32)
        T = reshape_from_csv_format(total_read_counts)

    def input_matrices(row_info):
        '''Generate R and b matrices from the given index and row.'''
        index, row = row_info
        if not treat_as_output and row.as_matrix(columns=df.columns[raw_start:raw_end]).sum() < MINIMUM_TOTAL_READ_COUNT:
            return None
        print("Processing sequence {} ({})...".format(index, row['seq']))
        R = reshape_from_csv_format(row.as_matrix(columns=df.columns[col_start:col_end]).astype(np.float32))
        b = create_b(R)
        return R, T, b, row['seq']

    def write_x_star_results(result):
        '''Write the results of x_star to the output path or to the console.'''

        if out_path is not None:
            # Write results to CSV
            with open(out_path, 'a') as out_file:
                out_file.write(','.join(result) + '\n')
        else:
            # Print results to console
            print(', '.join(result))

    processor = partial(run_x_star_processor, mode)
    if line_num is not None:
        # Process only the given line number
        row = df.iloc[line_num,:]
        print("Processing sequence {} ({})...".format(line_num, row[0]))
        write_x_star_results(processor(input_matrices(row)))
    else:
        # Process all lines using a multiprocess pool
        pool = multiprocessing.Pool(processes=num_processes)
        inputs = imap(input_matrices, df.iterrows())
        for result in map(processor, inputs): #pool.imap(processor, inputs):
            if result is None:
                continue
            write_x_star_results(result)


if __name__ == '__main__':
    a = time.time()  # Time the script started
    parser = argparse.ArgumentParser(description='Runs the TiteSeq calculation procedure on each of the sequences whose counts are given in the input file.')
    parser.add_argument('input', metavar='I', type=str,
                        help='The path to the input sequence counts file')
    parser.add_argument('output', metavar='O', type=str,
                        help='The path to the output directory')
    parser.add_argument('-m', '--mode', type=str, default=MODE_X_STAR,
                        help='The mode of fitting Kd (see top of script for possible values)')
    parser.add_argument('-to', '--treat-output', dest='treat_as_output',
                        action="store_true", help='Provide this flag to assume the input sequence counts file is formatted the same way as an output of this script')
    args = parser.parse_args()

    if not os.path.exists(args.output):
        os.mkdir(args.output)

    run_x_star(args.input, os.path.join(args.output, os.path.basename(args.input)), args.mode, treat_as_output=args.treat_as_output)

    b = time.time()
    print("Took {} seconds to execute.".format(b - a))

    # Write out the input parameters to file
    params_path = os.path.join(args.output, "params.txt")
    sc.write_input_parameters([(name, eval(name)) for name in PARAMETER_LIST], params_path)
